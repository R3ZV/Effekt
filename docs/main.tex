\documentclass[14pt]{extarticle}

% --------------------------------------------------
% Packages
% --------------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb, amsfonts}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{float}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{parskip} % For better paragraph spacing

\geometry{margin=2cm}

% --------------------------------------------------
% Hyperref setup
% --------------------------------------------------
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    citecolor=blue,
    pdftitle={Implementation of Different Filters}
}

% --------------------------------------------------
% Listings setup
% --------------------------------------------------
\lstset{
    backgroundcolor=\color{gray!10},
    basicstyle=\ttfamily\footnotesize,
    frame=single,
    numbers=left,
    numberstyle=\tiny,
    breaklines=true,
    tabsize=2,
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black}
}

% --------------------------------------------------
% Title
% --------------------------------------------------
\title{Effekt -- Implementation of Different Filters}
\author{Signal Processing Project}
\date{\today}

% --------------------------------------------------
% Document
% --------------------------------------------------
\begin{document}

\maketitle
\tableofcontents
\newpage

\section{State Variable Filter (SVF)}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{Effekt/SVF/SVF.png}
    \caption{SVF Discrete-Time Model (ZDF Topology)}
    \label{fig:SVF_diagram}
\end{figure}

\subsection{Description}

The State Variable Filter (SVF) is a highly versatile topology that simultaneously computes three primary filter outputs: low-pass ($y_{LP}$), high-pass ($y_{HP}$), and band-pass ($y_{BP}$). 

Based on the Zero-Delay Feedback (ZDF) structure, the band-pass output is derived as:
\[
y_{BP} = g(x - 2Ry_{BP} - gy_{BP} - s_2) + s_1
\]
Solving for $y_{BP}$ yields the stable implementation formula:
\[
y_{BP} = \frac{g(x - s_2) + s_1}{1 + g(g + 2R)}
\]
From this, the low-pass and high-pass outputs are extracted:
\begin{align*}
y_{LP} &= g \cdot y_{BP} + s_2 \\
y_{HP} &= x - 2R \cdot y_{BP} - y_{LP}
\end{align*}

This filter utilizes two trapezoidal integrators, represented as $g\xi + s_i$, where:
\begin{itemize}
    \item $g$: The zero-delay feedback gain.
    \item $\xi$: The instantaneous input of the integrator.
    \item $s_1, s_2$: The internal states (memory) of the integrators.
\end{itemize}

The parameter $g$ represents the cutoff frequency after \textbf{frequency prewarping}, which maps analog frequencies ($0$ to $\infty$) to digital frequencies ($0$ to Nyquist) using:
\[
g = \tan\left(\frac{\text{cutoff} \cdot \pi}{2}\right)
\]

\subsection{Results: Chester's Scream Analysis}

Below are the spectrograms for the outputs of the SVF filter applied to the vocals of Chester Bennington from Linkin Park's \href{https://www.youtube.com/watch?v=Gd9OhYroLN0}{"Crawling"} (20s--34s).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.48\linewidth]{Effekt/crawling_scream_spect_ch_0.png}
    \caption{Initial crawling}
    \label{fig:svf_band_pass_ex}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.48\linewidth]{Effekt/SVF/band_pass_crawling.png}
    \caption{Band-pass output (Cutoff: 0.15, Resonance: 0.5)}
    \label{fig:svf_band_pass_ex}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.48\linewidth]{Effekt/SVF/low_pass_crawling.png}
    \caption{Low-pass output (Cutoff: 0.15, Resonance: 0.5)}
    \label{fig:svf_low_pass_ex}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.48\linewidth]{Effekt/SVF/high_pass_crawling.png}
    \caption{High-pass output (Cutoff: 0.15, Resonance: 0.5)}
    \label{fig:svf_high_pass_ex}
\end{figure}

\subsection{Resonance and Damping}

The variable $R$ represents the \textbf{damping factor} (the mathematical inverse of resonance). It controls the amount of band-pass signal fed back into the summing junction. While the cutoff controls the frequency boundary, $R$ controls the amplitude peak at that boundary.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.48\linewidth]{Effekt/SVF/low_pass_crawling_low_res.png}
    \caption{Low-pass (Resonance: 0.01)}
    \label{fig:low_pass_crawling_low_res}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.48\linewidth]{Effekt/SVF/low_pass_crawling_super_high_res.png}
    \caption{Low-pass (Resonance: 0.99) -- Note the resonant peak.}
    \label{fig:low_pass_crawling_super_high_res}
\end{figure}

When resonance is high, an intense line appears at the cutoff frequency.

\subsection{Secondary Filter Types}

By linear combination of the primary SVF outputs, we can derive specialized filters.

\subsubsection*{Band-Shelving Filter}
Using a gain parameter $K$, we can boost or cut the band-pass region:
\[ y_{S} = x + 2RK \cdot y_{BP} \]
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Effekt/SVF/band_shelving_crawling.png}
    \caption{Band-shelving (Cutoff: 0.15, Res: 0.99, K: 0.5)}
    \label{fig:shelving_ex}
\end{figure}

\subsubsection*{Notch Filter}
A notch filter is achieved by setting $K = -1$, effectively subtracting the resonant peak from the input:
\[ y_{N} = x - 2R \cdot y_{BP} \]
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Effekt/SVF/notch_crawling.png}
    \caption{Notch filter (Cutoff: 0.15, Res: 0.99)}
    \label{fig:notch_ex}
\end{figure}

\subsubsection*{All-Pass Filter}
Setting $K = -2$ creates an all-pass response, affecting only phase:
\[ y_{AP} = x - 4R \cdot y_{BP} \]
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Effekt/SVF/all_pass_crawling.png}
    \caption{All-pass filter (Cutoff: 0.15, Res: 0.99)}
    \label{fig:all_pass_ex}
\end{figure}

\subsubsection*{Peaking Filter}
The peaking (or phase-flip) filter is derived from the difference of the low-pass and high-pass signals:
\[ y_{P} = y_{LP} - y_{HP} \]
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Effekt/SVF/peaking_crawling.png}
    \caption{Peaking filter output}
    \label{fig:peaking_ex}
\end{figure}

\section{Binaural Rotation}

This implementation is not a spectral filter, but rather a spatialization technique designed to simulate a monaural sound source moving horizontally ($360^{\circ}$ azimuth) around a listener's head. By transforming a mono input into a stereo output, we simulate the two primary cues used in human sound localization: Interaural Time Difference (ITD) and Interaural Level Difference (ILD).

\subsection{Interaural Time Difference (ITD)}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Effekt/Binaural/itd.png}
    \caption{Geometric representation of ITD based on the spherical head model.}
    \label{fig:itd_diagram}
\end{figure}

ITD represents the time delay incurred because the signal must travel different distances to reach each ear based on the source's position. As seen in Figure \ref{fig:itd_diagram}, a signal originating from the right will reach the right ear significantly earlier than the left.

Based on Woodworth’s formula, the time delay for a spherical head is calculated as:

\begin{equation}
ITD = \frac{r}{c}(\theta + \sin\theta)
\end{equation}

Where:
\begin{itemize}
    \item \textbf{$r$} is the radius of the listener's head (typically $\approx 0.0875$ m).
    \item \textbf{$c$} is the speed of sound (approximately $343$ m/s).
    \item \textbf{$\theta$} is the azimuth angle in radians ($0$ radians being directly in front).
\end{itemize}

The $\sin\theta$ term accounts for the direct line-of-sight path to the near ear, while the $\theta$ term represents the additional distance the sound wave must travel as it diffracts around the curved surface of the head to reach the "shadowed" far ear. In this implementation, the delay is applied only to the ear further from the source; for example, if $\sin(\theta) > 0$ (source in the right hemisphere), a delay is applied to the left channel.

\subsection{Interaural Level Difference (ILD)}

ILD models the variation in sound pressure level (amplitude) reaching each ear. The ear closer to the source perceives a higher amplitude, while the further ear perceives a lower amplitude due to the "head shadow" effect. To maintain a natural perception of volume during rotation, a Constant Power Panning law is utilized:

\begin{align}
G_{left} &= \cos\left(\frac{\theta}{2} + \frac{\pi}{4}\right) \\
G_{right} &= \sin\left(\frac{\theta}{2} + \frac{\pi}{4}\right)
\end{align}

These formulas leverage the trigonometric identity $\sin^2\theta + \cos^2\theta = 1$ to ensure that the total perceived power remains constant regardless of the angle. A $45^{\circ}$ ($\pi/4$) phase shift is applied to the coordinate system to ensure that at $\theta = 0$ (center), both gains are equal to $\approx 0.707$ (-3 dB), creating a stable phantom center.

\subsubsection{Acoustic shadow}

The human head blocks high frequencies and lets lower frequencies pass just like a low pass filter when the sound is further from the ear. This is especially true when it comes from behind(most notably the pina blocks back sounds by design).

For this two low pass filters (coming from a SVF) are used, one for the left, one for the right ear. The cutoffs for the filters are defined as follows:

\begin{itemize}
    \item \textbf{normal cutoff}: 0.99 (transparent)
    \item \textbf{shadow cutoff}: 0.35 (shadow effect based on whether the sound is left or right) 
    \item \textbf{rear cutoff}: 0.2 (amplified shadow effect when in the rear side)
\end{itemize}

The cutoff "sweeped" from normal to shadow and from shadow to rear based on the left factor($\sin \theta$), right factor ($-\sin \theta$) and the rear factor ($(1 - \cos \theta)*0.5$) using linear interpolation. First sweeping from normal cutoff to side cutoff using the side factor and then from the result of that to the rear cutoff using the rear factor.

\subsection{Results}

Applying this on the same input as the SVF here are the spectograms for the binaural rotation:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Effekt/Binaural/init_crawling_ch_0.png}
    \caption{Binaural rotation without svf low pass filtering left channel}
    \label{fig:init_crawling_ch_0}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Effekt/Binaural/init_crawling_ch_1.png}
    \caption{Binaural rotation without svf low pass filtering right channel}
    \label{fig:init_crawling_ch_1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Effekt/Binaural/svf_crawling_ch_0.png}
    \caption{Binaural rotation with svf low pass filtering left channel}
    \label{fig:svf_crawling_ch_0}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Effekt/Binaural/svf_crawling_ch1.png}
    \caption{Binaural rotation with svf low pass filtering right channel}
    \label{fig:svf_crawling_ch_1}
\end{figure}

Most notable are the difference in phase between the channels and that for the version that uses low pass filtering we see the frequencies steadily decrease and increase.


\section{Envelope Follower / Peak Detector}

While not a filter in the spectral sense, the Envelope Follower is a circuit that automatically detects and traces the contour (peaks) of the audio signal. This component is essential for dynamic effects, such as the automatic wah (crybaby) effect, where the filter cutoff frequency needs to respond to the playing intensity.

The behavior of the envelope follower is divided into two distinct phases, \textbf{Attack} and \textbf{Release}. In both phases, the envelope moves towards the instantaneous amplitude of the input signal, but usually at significantly different speeds:

\begin{itemize}
    \item \textbf{Attack Phase:} Occurs when the absolute value of the input $|x[n]|$ is \textit{greater} than the current envelope $e[n-1]$. The envelope rises quickly to catch the transient.
    \item \textbf{Release Phase:} Occurs when the input drops \textit{below} the current envelope. The envelope decays slowly, smoothing out the signal to prevent "zipper noise" or distortion.
\end{itemize}

In digital implementation, these speeds are defined by a time constant $\tau$ (measured in seconds), which represents the time it takes for the value to reach approximately $63.2\%$ of the target step. To simulate the physics of a real capacitor charging and discharging in an analog RC circuit, this time constant is converted into a filter coefficient using an exponential function dependent on the sampling rate $f_s$:

\begin{equation}
    \alpha = e^{- \frac{1}{\tau \cdot f_s}}
\end{equation}

Where:
\begin{itemize}
    \item $\alpha$ is the resulting Attack or Release coefficient (between 0 and 1).
    \item $\tau$ is the desired time constant in seconds.
    \item $f_s$ is the sampling rate in Hz.
\end{itemize}

This coefficient $\alpha$ is then used to perform a "leaky integration" (a weighted average), which linearly interpolates between the previous envelope state and the current input. The logic branches based on the signal direction:

\begin{equation}
    e[n] = 
    \begin{cases} 
        \alpha_{att} \cdot e[n-1] + (1 - \alpha_{att}) \cdot |x[n]| & \text{if } |x[n]| > e[n-1] \quad \text{(Attack)} \\
        \alpha_{rel} \cdot e[n-1] + (1 - \alpha_{rel}) \cdot |x[n]| & \text{if } |x[n]| \le e[n-1] \quad \text{(Release)}
    \end{cases}
\end{equation}

Where $e[n]$ is the current envelope value and $|x[n]|$ is the rectified (absolute) input signal.
\section{Crybaby Effect (Wah-Wah)}

The Crybaby effect is digitally implemented by applying a band-pass filter to the signal while simultaneously sweeping the cutoff frequency and resonance (Q-factor). The control mechanism creates the characteristic vocal-like sound.

The control signal, often represented as a "knob" value between 0 and 1, is typically mapped to a \textbf{triangular sweep}. This is done to simulate the physical motion of a real Wah pedal: as the player rocks the pedal back and forth, the value rises linearly to the maximum and falls linearly back to the minimum, creating a smooth, continuous modulation rather than an abrupt jump.

\subsection{Resonance Sweep}

For a convincing Crybaby effect, a relatively \textbf{high resonance} is preferred. This is because the "Wah" sound mimics human speech formants (specifically the transition from vowel 'u' to 'a'). A high Q-factor creates a sharp, narrow peak in the frequency spectrum, which is necessary to emulate these resonant vocal cavities.

The resonance is dynamically calculated using the following linear relationship:

\begin{equation}
    r[n] = r_{start} + r_{factor} \cdot s[n]
\end{equation}

Where:
\begin{itemize}
    \item $r[n]$ is the current resonance (Q) value.
    \item $r_{start}$ is the base resonance value (0.85)
    \item $r_{factor}$ is the \textbf{Resonance Sensitivity Factor}. This parameter defines the \textit{depth} of the modulation, determining how much the sharpness of the filter increases as the sweep reaches its peak.
    \item $s[n]$ is the current value of the triangular sweep (0.0 to 1.0).
\end{itemize}

\subsection{Cutoff Sweep}

The core of the effect lies in moving the center frequency of the band-pass filter. I explored two distinct methods for controlling this movement.

\subsubsection{Periodic Exponential Cutoff}

My first implementation used an automatic Low Frequency Oscillator (LFO) to move the filter. The triangular sweep control signal $s[n]$ was mapped to the frequency domain using an exponential curve:

\begin{equation}
    f_c[n] = f_{start} \cdot \left( \frac{f_{end}}{f_{start}} \right)^{s[n]}
\end{equation}

The exponential function is used because human hearing perceives pitch logarithmically. If a linear sweep were used (e.g., adding a fixed number of Hertz per step), the filter would appear to move very slowly through the bass frequencies and rush instantly through the high frequencies. An exponential sweep ensures that the musical interval (octaves per second) remains constant, resulting in a smooth, natural-sounding transition across the entire range.

\subsubsection{Envelope Follower Cutoff (Auto-Wah)}

The periodic LFO attempt successfully created a wah sound, but it was robotic and disconnected from the musical performance. To resolve this, I switched to an \textbf{Auto-Wah} architecture.

Instead of a pre-calculated triangular wave, this method uses the \textbf{Envelope Follower} described in the previous section to drive the cutoff frequency. This allows the effect to react to playing dynamics in real-time: picking a string harder generates a higher envelope value, which opens the filter to a higher frequency immediately. This dynamic interaction creates the expressive "quack" sound associated with funk music.

\subsection{Results}

This time a different signal was used, a raw sample from an electronic guitar interpreting \href{https://www.youtube.com/watch?v=0J2QdDbelmY}{Seven Nation Army}. Here is the spectogram for the initial sound:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Effekt/crybaby/init_raw-7arm.png}
    \caption{Raw guitar sample}
    \label{fig:init_raw-7arm}
\end{figure}

For all results the following were kept constant:

\begin{itemize}
    \item \textbf{Base resonance: 0.85}
    \item \textbf{Resonance factor: 0.12}
\end{itemize}

Here is the spectogram for the periodic exponential crybaby

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Effekt/crybaby/exp_raw-7army.png}
    \caption{Crybaby effect using periodic exponential sweep, sweep speed=1.5 Hz/s, cutoff start=450Hz, cutoff end=2500Hz}
    \label{fig:crybaby_exp_raw-7army}
\end{figure}

Here is the spectogram for the envelope follower crybaby:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Effekt/crybaby/ev_fol_raw-7army.png}
    \caption{Crybaby effect using envelope follower, attack period=10ms, release period=100ms}
    \label{fig:crybaby_ev_fol_raw-7army}
\end{figure}

\section{Bitcrusher}

The Bitcrusher is a digital-only effect that intentionally degrades audio quality by reducing both the vertical resolution (amplitude) and horizontal resolution (time) of the signal.

\subsection{Quantization (Bit Depth Reduction)}
The "bit" in "bitcrusher" refers to the binary representation of audio. In digital systems, dynamic range is defined by bit depth. We use \textbf{bits} as the parameter rather than direct integer levels for two primary reasons:
\begin{itemize}
    \item \textbf{Perceptual Scaling:} Human hearing is logarithmic. Adding 1 bit of resolution consistently provides a 6dB improvement in the signal-to-noise ratio, making bits a more musically intuitive unit than raw steps.
    \item \textbf{Hardware Emulation:} Using bits allows the filter to accurately mimic specific vintage hardware, such as 8-bit samplers or 12-bit drum machines, which are defined by their hardware architecture.
\end{itemize}

The formula for quantization of a normalized signal $x \in [-1, 1]$ is:

\[ y = \frac{\text{round}(x \cdot 2^{b-1})}{2^{b-1}} \]

\begin{itemize}
    \item \textbf{$y$}: output signal
    \item \textbf{$x$}: input signal
    \item \textbf{$b$}: number of bits (resolution)
\end{itemize}

\subsection{Dry/Wet Interpolation}
At the end of the processing chain, an interpolation is performed between the original input ($x$) and the crushed output ($y$). This is implemented to provide a "Mix" control because:
\begin{itemize}
    \item \textbf{Parallel Processing:} Bitcrushing is extremely destructive. Mixing in the "Dry" signal allows the listener to retain the fundamental clarity and transient punch of the original audio while adding the "crushed" texture as an overlay.
    \item \textbf{Harmonic Control:} Since bitcrushing adds significant high-frequency noise and aliasing, interpolation acts as a manual intensity knob, making the effect usable in a musical mix without over-powering other instruments.
\end{itemize}

\subsection{Results/Observations}
Playing around with the number of bits, I observed that leaving it between 0 and 4 does not offer much change because at such low resolution, the signal essentially becomes a square wave or pure noise. The same can be said about going after 16; since 16-bit is CD quality, the human ear struggles to hear further increases in resolution in a typical listening environment. 

Changing the sampling rate shows a more rapid change that "worsens the quality of the signal" through aliasing. Interestingly, as I decreased the sample rate, Chester's voice became more aggressive. This is due to the aliasing adding metallic, grit-like frequencies to the mid-range, which emphasizes the "fry" in the vocal delivery.

Here is the spectogram for the one that sounded "the best":

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Effekt/Bitcrusher/crawling_scream_ch0.png}
    \caption{Bitcrusher downsampling=8 samples, bit count=8}
    \label{fig:bitcrusher_crawling_scream_ch0}
\end{figure}

\section{Cabinet Simulation via Convolution}

\subsection{Concept}
To implement a realistic guitar cabinet simulation in software, we utilize \textbf{Convolution}.
This way we can apply the acoustic characteristics of a physical speaker cabinet
to a raw digital audio signal.

The core component of this simulation is the \textbf{Impulse Response (IR)}.
An IR is an audio recording that captures how in this case a guitar cabinet
reacts to instantaneous burst of energy.

When we convolve a dry guitar signal with this IR, we are essentially triggering
that recorded response for every single sample of the input guitar.

This filters the frequency content—removing the harsh, fizzy high frequencies
typical of direct-recorded distortion—and introduces the natural resonance and
short reverberations of the wooden cabinet structure.

\subsection{Source Material}
For this specific implementation, the impulse response captures a classic rock configuration:
\begin{itemize}
    \item \textbf{Cabinet:} Marshall 1960
    \item \textbf{Speakers:} Celestion G12M-25 "Greenbacks"
    \item \textbf{Microphone:} Shure SM57
    \item \textbf{Position:} Cap Edge, 0.5 inches distance
\end{itemize}
\section{Overdrive Effect (Diode Clipper)}

\subsection{Concept}
Overdrive creates distortion by "clipping" the peaks of an audio signal.
In the analog world, this is often achieved using diodes.
A diode allows current to flow easily in one direction but restricts it in the other,
and most importantly, it has a non-linear relationship between voltage and current.

When the signal volume is low, the diode acts like an open circuit, and the audio
passes unchanged. As the volume increases, the diode begins to conduct, "squashing" the amplitude.
This squares off the tops of the waveforms, resuling in signals that 
we perceive as "distortion."

\subsection{Implementation: Wave Digital Filters (WDF)}
Instead of processing simple voltages, this implementation uses \textbf{Wave Digital Filters}.
WDFs model circuits using wave variables (incident and reflected waves)
rather than Kirchhoff variables (voltage and current).

The relationship between physical variables ($v, i$) and wave variables ($a, b$)
at a port with port resistance $R$ is defined as:
\begin{align*}
    a &= v + R \cdot i \quad \text{(Incident Wave)} \\
    b &= v - R \cdot i \quad \text{(Reflected Wave)}
\end{align*}

This approach decouples the non-linear element (the diode) from the rest of
the circuit, allowing us to solve the non-linear equation locally without
affecting the stability of the entire system.

\subsection{The Physics: Shockley Diode Equation}

The behavior of the diode is governed by the \textbf{Shockley Diode Equation}:
$$ I_d = I_s (e^{V_d / V_t} - 1) $$
Where:
\begin{itemize}
    \item $I_d$: Diode current.
    \item $V_d$: Voltage across the diode.
    \item $I_s$: \textbf{Saturation Current}. The code uses $1\times10^{-9}$ (1nA) for
        positive voltage and $5\times10^{-8}$ (50nA) for negative.
        This asymmetry creates \textbf{Asymmetric Clipping}, which produces even-order harmonics,
        often associated with smoother, "tube-like" distortion.
    \item $V_t$: \textbf{Thermal Voltage}. Approximately $25.85\text{mV}$ at room temperature ($300\text{K}$).
\end{itemize}

\subsection{The Solver: Newton-Raphson Method}
Because the Shockley equation is implicit (current depends on voltage, but voltage depends on current in the circuit), we cannot solve it algebraically. We must find a value for $v$ that satisfies the WDF constraints.

We rearrange the WDF incident wave equation $a = v + R \cdot i(v)$ into a function $f(v)$ that equals zero:
$$ f(v) = v + R \cdot I_s (e^{v / V_t} - 1) - a_{in} = 0 $$

We solve for $v$ using the \textbf{Newton-Raphson method}, an iterative algorithm that approximates the root of a function:
$$ v_{n+1} = v_n - \frac{f(v_n)}{f'(v_n)} $$

Once $v$ is found, the reflected wave $b$ is calculated via $b = 2v - a$, which is returned to the circuit loop.

\section{Pitch Shifter Effect (Granular Synthesis)}

\subsection{Concept}
This implementation utilizes \textbf{Granular Synthesis} logic to achieve pitch shifting without altering the playback duration. 
The core principle mimics the \textbf{Doppler Effect}.
\begin{itemize}
    \item Playing audio back faster than it was recorded increases the pitch.
    \item Playing it back slower decreases the pitch.
\end{itemize}

However, simply changing the playback speed would cause the audio to drift
out of sync with the input stream (either running out of data or falling infinitely behind).
To solve this, the audio is sliced into small segments called
\textbf{"grains"} (typically 50--100ms).
The read pointer moves at the desired pitch speed within a grain but periodically
"jumps" back to align with the current write position.

\subsection{Implementation: Dual Delay Line}
A naive granular implementation creates audible discontinuities ("clicks")
whenever the read pointer jumps.
To eliminate these artifacts, this implementation
uses a \textbf{Dual Delay Line} approach with cross-fading.

We employ a circular buffer to store a history of the input signal.
Two separate read heads traverse this buffer:
\begin{itemize}
    \item \textbf{Head A}: The primary read pointer.
    \item \textbf{Head B}: A secondary pointer offset by exactly $180^\circ$ (0.5 phase).
\end{itemize}

As one head reaches the end of its grain (the discontinuity point), its volume is
faded to silence, while the other head is at the peak of its volume in the middle
of a grain. This ensures a continuous output signal.

\subsection{Mathematical Formulation}

\subsubsection{Phase Accumulator}
The position of the read heads is driven by a normalized phasor $\phi(n)$
that ranges from $0.0$ to $1.0$. The rate of change ($\Delta \phi$) determines the pitch shift:

$$ \Delta \phi = \frac{1.0 - P}{N_{grain}} $$

Where:
\begin{itemize}
    \item $P$: The pitch factor (e.g., $2.0$ for an octave up, $0.5$ for an octave down).
    \item $N_{grain}$: The size of a grain in samples.
\end{itemize}

The phasor for the current sample $n$ is updated as:
$$ \phi[n] = (\phi[n-1] + \Delta \phi) \pmod 1 $$

\subsubsection{Fractional Delay (Linear Interpolation)}
Since the read pointer often lands between integer sample indices (e.g., index 405.7), we must approximate the value using \textbf{Linear Interpolation} to avoid quantization noise (aliasing):

$$ y_{interp} = x[i] + \alpha \cdot (x[i+1] - x[i]) $$
Where:
\begin{itemize}
    \item $i$: The integer part of the read index ($\lfloor index \rfloor$).
    \item $\alpha$: The fractional part ($index - i$).
\end{itemize}

\subsubsection{Windowing Function}
To smooth the transition between grains, we apply a \textbf{Triangle Window} to both read heads. The weight $w$ for a given phase $\phi$ is calculated as:

$$ w(\phi) = 1.0 - 2.0 \cdot | \phi - 0.5 | $$

This function creates a triangular amplitude envelope:
\begin{itemize}
    \item At $\phi = 0.0$ or $1.0$ (grain edges), $w = 0$ (Silence).
    \item At $\phi = 0.5$ (grain center), $w = 1$ (Full Volume).
\end{itemize}

\subsubsection{The Final Summation}
The final output $y[n]$ is the sum of the two overlapping heads. Because Head B is offset by phase $0.5$, the sum of their weights is constant ($w_A + w_B = 1$), resulting in unity gain:

\begin{align*}
    \phi_A &= \phi[n] \\
    \phi_B &= (\phi[n] + 0.5) \pmod 1 \\
    y[n] &= \underbrace{(y_{\phi_A} \cdot w(\phi_A))}_{\text{Head A}} + \underbrace{(y_{\phi_B} \cdot w(\phi_B))}_{\text{Head B}}
\end{align*}

\end{document}
